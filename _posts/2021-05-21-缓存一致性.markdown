---
layout: post
title:  "缓存一致性"
date:   2021-05-21 10:24:00 +0800
author: Vito
categories: ["redis","缓存一致性"]
---
首先我们需要明确一点，强一致性和高性能是不可兼得的，所以如果需要保证强一致性，那么请不要使用缓存。
以下是讨论的比较多的，现在常用的两种优化缓存一致性的方式。

1.双删 - 先删缓存，再更新数据库，再删除缓存
在读写分离情况下，是会有问题的，容易出现从库没有同步到主库数据的情况，导致第二次删除的效果出现问题。
```
*线程A删除缓存
*线程A更新主库
*线程B从缓存未获取到数据，故从从库获取数据，此时主库数据binlog还未同步应用到从库，所以线程B获取到的是老数据
*线程A更新后再次删除缓存
*线程B由于缓存没有数据，判断需要用db获得的数据更新缓存
*缓存中将长期存在旧数据，而db中已经是新数据
```
此种情况下，应该根据主从同步时延，适当延长第二次删除的时间。

2.cache aside模式（基于写操作时间比读操作时间更长）
先更新db，后删除缓存（删除失败，可以用事务消息或者订阅binlog的方式重试，保证最终成功），这种方式同样存在一种可能导致脏数据的情况。
```
*缓存失效
*线程B从缓存未获取到数据，故从从库获取到老数据
*线程A更新主库
*线程A删除缓存
*线程B由于缓存没有数据，判断需要用db获得的老数据更新缓存
*缓存中将长期存在旧数据，而db中已经是新数据
```
但是，这种情况是常见的吗？他需要满足以下两个条件：1.缓存数据过期的同时，有db更新，2.数据库写操作耗时小于读操作耗时，而通常情况下是正好反的。
优势：其实如果采用了读写分离的架构，主从更新的延迟，在cacheaside模式中，也是会有的，但是因为没有前面的删除操作，通常情况下，不会有双删中，线程B读到旧数据，需要在线程A更新完db，删除完删除之后的更新缓存，造成数据不一致的情况。因此cache aside模式，不需要延迟较长时间来做更新db后的缓存删除（当然需要排除那一刻正好缓存失效的情况，小概率事件）